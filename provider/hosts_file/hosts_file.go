package hostsfile

import (
	"context"
	"fmt"
	"io/fs"
	"os"
	"strconv"
	"strings"

	scp "github.com/bramvdbogaerde/go-scp"
	"go.uber.org/zap"

	"github.com/sapslaj/zonepop/config/configtypes"
	"github.com/sapslaj/zonepop/endpoint"
	"github.com/sapslaj/zonepop/pkg/log"
	"github.com/sapslaj/zonepop/pkg/sshconnection"
	"github.com/sapslaj/zonepop/pkg/utils"
	"github.com/sapslaj/zonepop/provider"
)

type HostsFileProviderConfigSSH struct {
	Host     string
	Username string
	Password string
}

type HostsFileProviderConfig struct {
	RecordSuffix string
	File         string
	Permissions  string
	SSH          HostsFileProviderConfigSSH
}

type hostsFileProvider struct {
	config              HostsFileProviderConfig
	logger              *zap.Logger
	forwardLookupFilter configtypes.EndpointFilterFunc
}

func NewHostsFileProvider(
	providerConfig HostsFileProviderConfig,
	forwardLookupFilter configtypes.EndpointFilterFunc,
) (provider.Provider, error) {
	if providerConfig.Permissions == "" {
		providerConfig.Permissions = "0644"
	}
	p := &hostsFileProvider{
		config:              providerConfig,
		logger:              log.MustNewLogger().Named("hosts_file_provider"),
		forwardLookupFilter: forwardLookupFilter,
	}
	return p, nil
}

func (p *hostsFileProvider) UpdateEndpoints(ctx context.Context, endpoints []*endpoint.Endpoint) error {
	// TODO: reverse lookup?
	forwardEndpoints := utils.Filter(p.forwardLookupFilter, endpoints)
	result := p.endpointsToFile(forwardEndpoints)
	var err error
	if p.config.SSH.Host != "" {
		err = p.saveToSSH(ctx, result)
		if err != nil {
			p.logger.Sugar().Errorw("failed to save to local file", "err", err)
		}
	} else {
		err = p.saveToLocalFile(ctx, result)
		if err != nil {
			p.logger.Sugar().Errorw("failed to save to remote SSH file", "err", err)
		}
	}
	return err
}

func (p *hostsFileProvider) endpointsToFile(endpoints []*endpoint.Endpoint) string {
	p.logger.Sugar().Infof("generating %d host file entries", len(endpoints))
	var s strings.Builder
	s.WriteString("# Generated by ZonePop\n")
	for _, endpoint := range endpoints {
		hostname := endpoint.Hostname + p.config.RecordSuffix
		for _, ipv4 := range endpoint.IPv4s {
			s.WriteString(fmt.Sprintf("%s\t%s\n", ipv4, hostname))
		}
		for _, ipv6 := range endpoint.IPv6s {
			s.WriteString(fmt.Sprintf("%s\t%s\n", ipv6, hostname))
		}
	}
	return s.String()
}

func (p *hostsFileProvider) saveToLocalFile(ctx context.Context, result string) error {
	p.logger.Sugar().Infof("saving hosts file to (local) %s with permissions %s", p.config.File, p.config.Permissions)
	perm, err := strconv.ParseInt(p.config.Permissions, 8, 0)
	if err != nil {
		return err
	}
	p.logger.Sugar().Infof("perm: %s  %d", p.config.Permissions, fs.FileMode(perm))
	return os.WriteFile(p.config.File, []byte(result), fs.FileMode(perm))
}

func (p *hostsFileProvider) saveToSSH(ctx context.Context, result string) error {
	p.logger.Sugar().Infof("saving hosts file to (SSH) %s:%s with permissions %s", p.config.SSH.Host, p.config.File, p.config.Permissions)
	conn, err := sshconnection.Connect(p.config.SSH.Host, p.config.SSH.Username, p.config.SSH.Password)
	if err != nil {
		return err
	}
	defer conn.Disconnect()
	client, err := scp.NewClientBySSH(conn.Client)
	if err != nil {
		return err
	}
	reader := strings.NewReader(result)
	return client.CopyFile(ctx, reader, p.config.File, p.config.Permissions)
}
